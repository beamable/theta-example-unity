using System;
using System.Linq;
using System.Threading.Tasks;
using Beamable.Api.Autogenerated.Models;
using Beamable.Common;
using Beamable.Common.Api;
using Beamable.Microservices.ThetaFederation.Endpoints;
using Beamable.Microservices.ThetaFederation.Features.Accounts;
using Beamable.Microservices.ThetaFederation.Features.Contracts;
using Beamable.Microservices.ThetaFederation.Features.Minting.Exceptions;
using Beamable.Microservices.ThetaFederation.Features.Transactions.Storage;
using Beamable.Server.Api.Notifications;
using Nethereum.RPC.Eth.DTOs;

namespace Beamable.Microservices.ThetaFederation.Features.Minting
{
    public class MintScheduler : IService
    {
        private readonly ContractProxy _contractProxy;
        private readonly TransactionLogCollection _transactionLogCollection;
        private readonly IBeamableRequester _beamableRequester;
        private readonly AccountsService _accountsService;
        private readonly GetInventoryStateEndpoint _getInventoryStateEndpoint;
        private readonly IMicroserviceNotificationsApi _notificationsApi;

        public MintScheduler(ContractProxy contractProxy, IBeamableRequester beamableRequester, AccountsService accountsService, GetInventoryStateEndpoint getInventoryStateEndpoint, IMicroserviceNotificationsApi notificationsApi, TransactionLogCollection transactionLogCollection)
        {
            _contractProxy = contractProxy;
            _beamableRequester = beamableRequester;
            _accountsService = accountsService;
            _getInventoryStateEndpoint = getInventoryStateEndpoint;
            _notificationsApi = notificationsApi;
            _transactionLogCollection = transactionLogCollection;
        }

        public async Task ProcessTransaction(string transactionHash)
        {
            try
            {
                var transactionLog = await _transactionLogCollection.GetByChainTransactionHash(transactionHash);
                var receipt = await _contractProxy.FetchTransactionReceiptAsync(transactionHash);
                if (receipt.Succeeded())
                {
                    if (transactionLog is not null)
                    {
                        await _transactionLogCollection.SetMined(transactionLog.Id);

                        var gamerTag = await GetGamerTag(transactionLog.Wallet);
                        if (gamerTag > 0)
                        {
                            await SynchronizeState(gamerTag, transactionLog.Wallet);
                        }
                    }
                    else
                    {
                        BeamableLogger.Log("Can't find transaction {hash}", transactionHash);
                    }
                }
                else
                {
                    if (transactionLog is not null)
                    {
                        await _transactionLogCollection.SetError(transactionLog.Id, $"Receipt status {receipt.Status}.");
                    }
                    throw new MintSchedulerExceptions($"Retry FetchReceiptAsync for transaction {transactionHash}");
                }
            }
            catch (Exception e)
            {
                BeamableLogger.LogException(e);
                throw new MintSchedulerExceptions(e.Message);
            }
        }

        private async Task<long> GetGamerTag(string walletAddress)
        {
            var account = await _accountsService.SearchAccount(walletAddress);
            if (account is null)
            {
                BeamableLogger.LogError("Account not found for wallet {address}", walletAddress);
                return 0;
            }

            var gamerTag = account.gamerTags
                .Where(x => x.projectId == _beamableRequester.Pid)
                .Select(x => x.gamerTag)
                .FirstOrDefault();

            if (gamerTag == 0)
            {
                BeamableLogger.LogError("Can't find a gamerTag on project {pid} for account {aid}", _beamableRequester.Pid, account.id);
            }

            return gamerTag;
        }

        private async Task SynchronizeState(long gamerTag, string walletAddress)
        {
            try
            {
                var newState = await _getInventoryStateEndpoint.GetInventoryState(walletAddress);

                BeamableLogger.Log("Reporting back state for user {gamerTag}", gamerTag);
                await _beamableRequester.Request<CommonResponse>(Method.PUT, $"/object/inventory/{gamerTag}/proxy/state", newState, includeAuthHeader: false);
            }
            catch (Exception e)
            {
                BeamableLogger.LogError("Error synchronizing inventory for user {gamerTag}, wallet {w}", gamerTag, walletAddress);
                BeamableLogger.LogError(e);
            }
        }
    }
}