using System;
using System.Linq;
using System.Threading.Tasks;
using Beamable.Api.Autogenerated.Accounts;
using Beamable.Common;
using Beamable.Common.Dependencies;
using Beamable.Microservices.ThetaFederation.Features.Accounts.Storage;
using Beamable.Microservices.ThetaFederation.Features.Accounts.Storage.Models;
using Microsoft.Extensions.Caching.Memory;
using Microsoft.Extensions.Options;
using Nethereum.KeyStore;
using Nethereum.KeyStore.Model;
using Nethereum.Signer;
using Nethereum.Web3.Accounts;

namespace Beamable.Microservices.ThetaFederation.Features.Accounts
{
    public class AccountsService : IService
    {
        private const string RealmAccountName = "default-account";
        private readonly IDependencyProvider _dependencyProvider;
        private readonly AccountsApi _accountsApi;
        private readonly KeyStoreScryptService _keystoreService = new();
        private readonly VaultCollection _vaultCollection;

        private Account? _cachedRealmAccount;
        private readonly MemoryCache _accountCache = new(Options.Create(new MemoryCacheOptions()));

        public AccountsService(VaultCollection vaultCollection, IDependencyProvider dependencyProvider,
            AccountsApi accountsApi)
        {
            _vaultCollection = vaultCollection;
            _dependencyProvider = dependencyProvider;
            _accountsApi = accountsApi;
        }

        public async Task<Account> GetOrCreateAccount(string accountName)
        {
            var account = await GetAccount(accountName);
            if (account is null)
            {
                account = await CreateAccount(accountName, Configuration.GetPlayerWalletScryptParams());
                if (account is null)
                {
                    BeamableLogger.LogWarning("Account already created, fetching again");
                    return await GetOrCreateAccount(accountName);
                }

                BeamableLogger.Log("Saved account {accountName} -> {accountAddress}", accountName, account.Address);
            }

            return account;
        }

        public async ValueTask<Account> GetOrCreateRealmAccount(string? existingKey = null)
        {
            if (_cachedRealmAccount is not null)
                return _cachedRealmAccount;

            var account = await GetAccount(RealmAccountName);
            if (account is null)
            {
                account = await CreateAccount(RealmAccountName, existingKey: existingKey);
                if (account is null)
                {
                    BeamableLogger.LogWarning("Account already created, fetching again");
                    return await GetOrCreateRealmAccount();
                }

                BeamableLogger.Log("Saved account {accountName} -> {accountAddress}", RealmAccountName,
                    account.Address);
                BeamableLogger.LogWarning(
                    "Please add some gas money to your account {accountAddress} to be able to pay for fees.",
                    account.Address);
            }

            account.NonceService = new MongoNonceService(_dependencyProvider, account.Address);
            account.TransactionManager.UseLegacyAsDefault = false;
            _cachedRealmAccount = account;

            return account;
        }

        public async Task<string?> GetGamerTagByWalletAddress(string address)
        {
            return await _vaultCollection.GetNameByAddress(address);
        }

        public async Task<Beamable.Api.Autogenerated.Models.Account?> SearchAccount(string query)
        {
            var searchResponse = await _accountsApi.GetSearch(1, 1, query);
            return searchResponse?.accounts.FirstOrDefault();
        }

        private async Task<Account?> GetAccount(string accountName)
        {
            return await _accountCache.GetOrCreateAsync(accountName, async cacheEntry =>
            {
                var vault = await _vaultCollection.GetVaultByName(accountName);
                if (vault is null)
                {
                    cacheEntry.Dispose();
                    return null;
                }

                cacheEntry.SlidingExpiration = TimeSpan.FromMinutes(5);
                var decryptedKeystore = _keystoreService.DecryptKeyStore(Configuration.RealmSecret, vault.Value);
                return new Account(decryptedKeystore);
            });
        }

        private async Task<Account?> CreateAccount(string accountName, ScryptParams? scryptParams = null,
            string? existingKey = null)
        {
            var ecKey = existingKey is null ? EthECKey.GenerateKey() : new EthECKey(existingKey);
            var privateKeyBytes = ecKey.GetPrivateKeyAsBytes();
            var newAccount = new Account(privateKeyBytes);

            KeyStore<ScryptParams> keyStore = scryptParams is null
                ? _keystoreService.EncryptAndGenerateKeyStore(Configuration.RealmSecret, privateKeyBytes,
                    newAccount.Address)
                : _keystoreService.EncryptAndGenerateKeyStore(Configuration.RealmSecret, privateKeyBytes,
                    newAccount.Address, scryptParams);

            return await _vaultCollection.TryInsertVault(new Vault
            {
                Name = accountName,
                Value = keyStore
            })
                ? newAccount
                : null;
        }
    }
}